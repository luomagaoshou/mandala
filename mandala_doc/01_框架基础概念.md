# Mandala框架基础概念

## 框架简介

Mandala是一个为Python计算项目设计的高级实验跟踪框架，消除了开发者通常需要付出的额外努力来持久化、迭代、查询、版本控制和重现计算结果。与传统的实验跟踪工具不同，Mandala直接集成到Python代码执行中，自动捕获函数调用的输入、输出和代码依赖关系。

Mandala的名称来源于梵语中"曼陀罗"，代表着复杂而有序的结构，这也反映了框架对复杂计算过程的组织方式。

## 核心组件

Mandala框架由以下核心组件构成：

### 1. Storage

`Storage`是Mandala的核心存储系统，负责保存、检索和管理所有计算结果：

```python
from mandala.imports import *

# 创建内存存储
storage = Storage()

# 或创建持久化存储（SQLite文件）
storage = Storage(db_path="my_computations.db")

# 启用依赖跟踪
storage_with_deps = Storage(
    db_path="computations.db",
    deps_path=".",  # 跟踪当前目录中的代码
)
```

`Storage`实例通常通过上下文管理器使用：

```python
# 使用上下文管理器包装要跟踪的代码
with storage:
    result = my_function(parameters)
```

### 2. @op装饰器

`@op`装饰器是Mandala的核心功能，它自动捕获和跟踪函数的调用：

```python
@op
def process_data(data, factor=2):
    return data * factor
```

当装饰函数被调用时，Mandala会：
- 自动保存输入参数和返回值
- 跟踪函数的代码及其依赖
- 在相同输入和代码版本下重用之前的结果

### 3. ComputationFrame

`ComputationFrame`是一个高级数据结构，提供了对保存的计算历史的查询和操作能力：

```python
# 获取特定计算的ComputationFrame
cf = storage.cf(result)

# 或基于特定操作的所有调用创建
cf = storage.cf(process_data)
```

`ComputationFrame`可以看作是`pandas.DataFrame`的泛化，它不仅表示表格数据，还表示计算图结构和执行历史。

### 4. 版本控制系统

Mandala内置了代码版本控制系统，可以跟踪函数实现的变化，并确定是否需要重新计算：

```python
# 启用依赖跟踪的装饰器
@track
def helper_function(x):
    return x * x

# 当helper_function变化时，依赖它的@op函数会被标记为需要重新计算
```

## 基本工作流程

Mandala框架的基本工作流程如下：

1. **初始化存储**：创建`Storage`实例来管理计算历史。

2. **定义操作**：使用`@op`装饰需要跟踪的函数。

3. **执行计算**：在`Storage`上下文中执行计算，自动保存所有调用信息。

4. **分析结果**：使用`ComputationFrame`查询和分析保存的计算历史。

5. **迭代开发**：修改函数实现，Mandala会自动处理版本控制和缓存失效。

基本示例：

```python
from mandala.imports import *
import time

# 1. 初始化存储
storage = Storage()

# 2. 定义操作
@op
def slow_computation(x):
    print(f"Computing for input {x}...")
    time.sleep(2)  # 模拟耗时计算
    return x * 10

# 3. 执行计算
with storage:
    # 第一次调用会执行
    result1 = slow_computation(5)
    print(f"Result: {result1}")
    
    # 第二次调用相同函数+参数会直接返回缓存结果（不会执行函数体）
    result2 = slow_computation(5)
    print(f"Result: {result2}")
    
    # 不同参数会触发新计算
    result3 = slow_computation(7)
    print(f"Result: {result3}")

# 4. 分析结果
cf = storage.cf(slow_computation)
print("计算历史:")
print(cf.df())
```

## 设计理念

Mandala的设计理念基于以下核心原则：

### 1. 自动化记忆化（Memoization）

Mandala将函数调用的记忆化（缓存）集成到框架中，自动重用过去的计算结果，消除冗余计算。

### 2. 计算即数据

Mandala将计算过程视为数据，通过`ComputationFrame`数据结构实现对计算的查询和操作。

### 3. 代码感知

Mandala跟踪代码变化并适当地使缓存失效，确保结果的正确性，同时保留兼容更改的灵活性。

### 4. 内省与分析

Mandala提供丰富的内省和分析工具，帮助理解计算关系、数据流和依赖，促进更好的代码组织和优化。

### 5. 最小侵入性

Mandala的API设计尽量减少对现有代码的改动需求，只需添加少量装饰器和上下文管理器即可启用全部功能。

## 与其他工具的区别

与传统的实验跟踪工具（如MLflow、Weights & Biases等）相比，Mandala有以下独特优势：

1. **更细粒度的跟踪**：跟踪单个函数调用而非整个脚本或实验。
2. **自动缓存**：自动重用过去的计算结果，加速迭代开发。
3. **代码版本感知**：自动检测代码变化，正确处理缓存失效。
4. **ComputationFrame**：提供高级数据结构，简化对计算历史的查询和操作。
5. **透明集合处理**：自动跟踪集合（列表、字典等）中的每个元素。

Mandala不仅适用于机器学习实验，还适用于任何需要跟踪和分析计算历史的场景，如数据处理管道、参数扫描研究等。