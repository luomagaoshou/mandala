# 函数跟踪与装饰器

函数跟踪是Mandala框架的核心功能，通过装饰器实现自动捕获函数调用的输入、输出和代码依赖。本文档详细介绍了相关装饰器的使用方法和高级功能。

## @op装饰器详解

`@op`装饰器是Mandala的主要入口点，将普通Python函数转换为可跟踪的操作：

```python
from mandala.imports import *

@op
def add(a, b):
    return a + b
```

### 基本功能

当使用`@op`装饰函数时，以下功能被自动启用：

1. **自动记忆化**：相同输入的重复调用不会重新执行，而是直接返回缓存结果
2. **输入输出追踪**：保存所有函数调用的输入参数和返回值
3. **代码版本跟踪**：检测函数实现变化并适当处理缓存失效

### 装饰器参数

`@op`装饰器支持多种参数来自定义其行为：

```python
@op(
    output_names=["sum", "product"],  # 多输出函数的输出名称
    nout="auto",                      # 输出数量，可以是整数或"auto"/"var"
    ignore_args=("verbose",)          # 在缓存键计算中忽略的参数
)
def calculate(a, b, verbose=False):
    if verbose:
        print(f"Calculating for {a} and {b}")
    return a + b, a * b
```

#### output_names

当函数返回多个值时，`output_names`可以为每个输出指定名称：

```python
@op(output_names=["mean", "std"])
def compute_stats(data):
    return sum(data)/len(data), ((sum((x - (sum(data)/len(data)))**2 for x in data)/len(data))**0.5)

with storage:
    mean, std = compute_stats([1, 2, 3, 4, 5])
```

在ComputationFrame中，这些输出将使用指定的名称而不是默认的`output_0`、`output_1`等。

#### nout

`nout`参数指定函数返回的值的数量：
- 整数：固定数量的输出
- `"auto"`：自动检测（默认）
- `"var"`：可变数量的输出

```python
@op(nout=3)  # 明确指定返回3个值
def split_data(data, ratios):
    # 根据给定比例分割数据
    total = sum(ratios)
    normalized = [r/total for r in ratios]
    splits = []
    start = 0
    for r in normalized:
        end = start + int(len(data) * r)
        splits.append(data[start:end])
        start = end
    return tuple(splits)
```

#### ignore_args

`ignore_args`参数指定在计算缓存键时要忽略的参数，通常用于不影响计算结果的标志：

```python
@op(ignore_args=("verbose", "log_progress"))
def process_data(data, transformations, verbose=False, log_progress=False):
    result = data.copy()
    for t in transformations:
        if verbose:
            print(f"Applying {t}")
        result = apply_transformation(result, t)
        if log_progress:
            log(f"Applied {t}, intermediate shape: {result.shape}")
    return result
```

这样，无论`verbose`和`log_progress`的值如何，只要`data`和`transformations`相同，Mandala就会重用之前的计算结果。

### 特殊输入处理

Mandala提供了特殊的包装器来控制参数如何影响缓存键计算：

#### Ignore

`Ignore`包装器标记不应该影响缓存键的参数：

```python
from mandala.imports import Ignore

@op
def process_with_logger(data, logger=Ignore(None)):
    if logger:
        logger.info("Processing data...")
    return data * 2
```

#### NewArgDefault

`NewArgDefault`用于向现有函数添加新参数，保持与旧版本的兼容性：

```python
from mandala.imports import NewArgDefault

# 原始版本
@op
def normalize(data):
    return data / max(data)

# 更新版本（添加新参数）
@op
def normalize(data, min_max=NewArgDefault(False)):
    if min_max:
        return (data - min(data)) / (max(data) - min(data))
    return data / max(data)
```

当使用`min_max=False`调用时，会匹配旧版本的调用，避免重新计算。

#### ValuePointer

`ValuePointer`允许通过引用而非值传递大型对象：

```python
from mandala.imports import ValuePointer
import numpy as np

# 创建大型数据集
large_dataset = np.random.random((10000, 1000))

# 用ValuePointer包装
dataset_pointer = ValuePointer(id="training_dataset_v1", obj=large_dataset)

@op
def train_model(data, hyperparams):
    # data将是large_dataset而不是一个引用
    model = create_model(hyperparams)
    model.fit(data)
    return model

with storage:
    model = train_model(dataset_pointer, {"learning_rate": 0.01})
```

`ValuePointer`在计算缓存键时只使用`id`，而不考虑实际对象，适用于不想或不能序列化的大型对象。

## 函数依赖跟踪

Mandala可以跟踪`@op`装饰函数的依赖，确保当依赖变化时正确处理缓存失效。

### @track装饰器

`@track`装饰器用于标记应该被跟踪的函数依赖：

```python
from mandala.imports import track

@track
def helper_function(x):
    return x * x + 1

@op
def compute(a):
    return helper_function(a) + helper_function(a + 1)
```

当`helper_function`的实现变化时，Mandala会检测到变化，并根据需要重新计算依赖于它的`compute`函数调用。

### 自动依赖检测

使用`deps_path`参数创建Storage时，Mandala可以自动监控指定路径中的代码变化：

```python
storage = Storage(
    db_path="computations.db",
    deps_path="."  # 监控当前目录中的所有Python代码
)
```

这使Mandala能够跟踪不仅仅是被`@track`装饰的函数，还包括项目中的其他模块和函数。

## 版本管理机制

Mandala的版本管理系统负责跟踪代码变化并决定何时重新计算。

### 版本检测

当在Storage上下文中执行代码时，Mandala会比较当前代码与上次执行时的代码：

```python
with storage:
    # 如果add函数发生变化，Mandala会检测到并提示
    result = add(1, 2)
```

当检测到变化时，Mandala会显示差异并询问这是否是语义变化（需要重新计算）。

### 查看版本历史

可以使用`versions`和`source_history`方法查看函数的版本历史：

```python
# 显示函数所有版本
storage.versions(add)

# 显示函数源代码历史
storage.source_history(add)

# 查看特定版本的代码
storage.code(version_id)
```

### 手动控制版本

对于需要手动控制版本处理的情况，可以使用`sync_component`方法：

```python
# 修改函数后手动同步
@op
def enhanced_add(a, b):
    return a + b + 0.01  # 微小修改

# 将变化标记为非语义变化（不需要重新计算）
storage.sync_component(enhanced_add, is_semantic_change=False)
```

## 自动缓存与重用

Mandala的核心功能之一是自动缓存和重用计算结果。

### 缓存机制

Mandala使用复杂的缓存机制来决定是否重用之前的计算结果：

1. **内容哈希**：基于输入参数内容（而非身份）计算哈希
2. **历史哈希**：考虑输入的来源（创建它们的操作）
3. **代码版本**：考虑函数实现及其依赖的版本

只有当所有这些因素都匹配时，才会重用之前的结果。

### 控制缓存行为

可以通过几种方式控制Mandala的缓存行为：

```python
# 使用noop上下文禁用存储
with noop():
    # 这个调用不会被存储或检索
    result = add(1, 2)

# 禁止创建新调用（只允许读取现有结果）
storage.allow_new_calls(False)
with storage:
    # 如果这个调用在存储中不存在，将会失败
    result = add(1, 2)
```

### 缓存管理

Mandala提供了几种管理缓存的方法：

```python
# 清除内存缓存（不影响持久化存储）
storage.clear_cache()

# 缓存信息
storage.cache_info()

# 提交更改到持久化存储
storage.commit()

# 预加载缓存以提高性能
storage.preload()
storage.preload_calls()
```

## 完整示例

以下是一个展示Mandala函数跟踪完整功能的示例：

```python
from mandala.imports import *
import time
import math

# 创建带有依赖跟踪的存储
storage = Storage(
    db_path="math_operations.db",
    deps_path="__main__"
)

# 定义一个跟踪的依赖函数
@track
def complex_operation(x):
    return math.sin(x) * math.cos(x/2)

# 定义一个带有多输出的操作
@op(output_names=["result", "computation_time"])
def timed_math(value, iterations=100):
    start = time.time()
    result = value
    for _ in range(iterations):
        result = complex_operation(result)
    end = time.time()
    return result, end - start

# 定义一个使用Ignore的函数
@op(ignore_args=("verbose",))
def analyze_results(values, verbose=False):
    if verbose:
        print(f"Analyzing {len(values)} values...")
    return {
        "min": min(values),
        "max": max(values),
        "avg": sum(values) / len(values)
    }

# 执行计算
with storage:
    print("执行计算...")
    
    # 使用不同参数多次调用
    results = []
    times = []
    
    for i in range(5):
        result, comp_time = timed_math(i / 10, iterations=100)
        results.append(result)
        times.append(comp_time)
        print(f"Value: {i/10}, Result: {result:.6f}, Time: {comp_time:.6f}s")
    
    # 分析结果
    stats = analyze_results(results, verbose=True)
    print(f"Statistics: {stats}")
    
    # 再次调用相同函数应该使用缓存
    print("\n再次调用（应使用缓存）...")
    cached_result, cached_time = timed_math(0.2, iterations=100)
    print(f"Cached result: {cached_result:.6f}, Time: {cached_time:.6f}s")

# 查看计算历史
cf = storage.cf(timed_math)
print("\n计算图信息:")
cf.info()

# 查看调用数据
df = cf.df()
print("\n计算历史数据框:")
print(df)

# 查看版本信息
print("\n函数版本信息:")
storage.versions(timed_math)
```

这个例子展示了Mandala函数跟踪的多个方面：
- `@op`装饰器的基本使用
- 命名多输出
- 依赖跟踪
 