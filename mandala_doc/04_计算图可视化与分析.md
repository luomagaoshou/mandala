# 计算图可视化与分析

Mandala框架提供了强大的计算图可视化和分析功能，帮助用户理解函数调用关系、数据流和依赖结构。本文档详细介绍这些功能的使用方法，特别是`cf.draw()`方法、计算图分析技术以及与NetworkX等图分析库的集成。

## cf.draw()方法详解

ComputationFrame的`draw()`方法是可视化计算图的主要工具，它将计算图渲染为可视化图形：

```python
from mandala.imports import *

@op
def add(a, b):
    return a + b

@op
def multiply(a, b):
    return a * b

with Storage() as s:
    x = add(1, 2)
    y = multiply(x, 3)
    z = add(y, 4)
    
    # 创建计算框架
    cf = s.cf(z)
    
    # 基本可视化
    cf.draw()
```

### 基本参数

`draw()`方法支持多种参数来自定义可视化效果：

```python
cf.draw(
    show_how="inline",    # 显示方式: "inline", "window", None
    path="graph.png",     # 保存文件路径
    verbose=False,        # 是否显示详细信息
    print_dot=False,      # 是否打印DOT代码
    orientation="TB"      # 图形方向: "TB"(上到下), "LR"(左到右)
)
```

#### show_how

控制图形的显示方式：
- `"inline"`：在Jupyter笔记本等支持内联显示的环境中直接显示
- `"window"`：在单独窗口中显示（需要系统支持）
- `None`：不显示，只保存（当指定`path`时）

#### path

指定保存可视化结果的文件路径，支持多种格式，如PNG、SVG、PDF等。

#### verbose

当设置为`True`时，在节点上显示更详细的信息。

#### print_dot

当设置为`True`时，打印生成的DOT代码，用于调试或进一步自定义。

#### orientation

控制图形的方向：
- `"TB"`：从上到下（默认）
- `"LR"`：从左到右

### 高级可视化选项

ComputationFrame可视化使用Graphviz作为后端，提供丰富的展示选项：

```python
# 展示一个复杂的计算图
complex_cf = storage.cf(complex_result)

# 左到右布局，保存为SVG格式
complex_cf.draw(
    path="complex_graph.svg",
    orientation="LR",
    verbose=True
)
```

这将生成一个详细的计算图，其中：
- 变量节点显示为椭圆
- 函数节点显示为矩形
- 边显示为带有标签的箭头，指示数据流方向

## 可视化选项与参数

除了基本的`draw()`方法，Mandala还提供了其他方式来可视化和理解计算图：

### 1. 信息查询

```python
# 显示计算图的摘要信息
cf.info()

# 显示特定节点的详细信息
cf.info("node_name")

# 获取图的文本描述
graph_desc = cf.get_graph_desc()
print(graph_desc)
```

### 2. 结构查看

```python
# 打印计算图的结构
cf.print_graph()

# 查看边列表
edges = cf.edges()
for src, dst, label in edges:
    print(f"{src} --({label})--> {dst}")
```

### 3. 数据框表示

计算图也可以通过数据框进行可视化和分析：

```python
# 获取计算历史数据框
df = cf.df()
print(df)

# 加载实际值
value_df = cf.eval_df(df)
print(value_df)
```

## 计算图分析技术

Mandala提供了多种技术来分析计算图的结构和特性：

### 1. 拓扑分析

```python
# 获取拓扑排序
topo_order = cf.topsort_modulo_sccs()
print("节点的拓扑顺序:", topo_order)

# 查找源节点（没有输入的节点）
sources = cf.sources
print("源节点:", sources)

# 查找汇节点（没有输出的节点）
sinks = cf.sinks
print("汇节点:", sinks)
```

### 2. 路径分析

```python
# 找出两个节点之间的所有边
paths_edges = cf.get_all_edges_on_paths_between("start_node", "end_node")
print("路径上的边:", paths_edges)
```

### 3. 可达性分析

```python
# 查找可达节点
reachable = cf.get_reachable_nodes({"node1"}, direction="forward")
print("从node1可达的节点:", reachable)

# 分析可达元素
reachable_elts = cf.get_reachable_elts_acyclic(
    initial_state={"var1": {ref1, ref2}},
    how="strong",
    direction="forward"
)
print("可达元素:", reachable_elts)
```

### 4. 统计分析

```python
# 获取变量统计
var_stats = cf.get_var_stats()
print("变量统计:\n", var_stats)

# 获取函数统计
func_stats = cf.get_func_stats()
print("函数统计:\n", func_stats)
```

## 导出与共享

Mandala计算图可以以多种方式导出和共享：

### 1. 图像导出

```python
# 导出为PNG图像
cf.draw(path="computation_graph.png")

# 导出为SVG矢量图（适合缩放）
cf.draw(path="computation_graph.svg")

# 导出为PDF文档
cf.draw(path="computation_graph.pdf")
```

### 2. 数据导出

```python
# 导出为CSV文件
df = cf.df()
df.to_csv("computation_history.csv")

# 导出为Excel文件
df.to_excel("computation_history.xlsx")
```

### 3. DOT格式导出

DOT是一种用于描述图的文本格式，可以被多种图可视化工具处理：

```python
# 获取DOT代码
cf.draw(print_dot=True)
```

可以将这个DOT代码保存到文件，然后使用Graphviz等工具进一步处理。

## 与NetworkX集成

Mandala的计算图可以与NetworkX图库集成，以利用其丰富的图分析功能。以下是如何将ComputationFrame转换为NetworkX图的方法：

```python
import networkx as nx
import matplotlib.pyplot as plt

def mandala_cf_to_networkx(cf):
    """将Mandala ComputationFrame转换为NetworkX图"""
    G = nx.DiGraph()
    
    # 添加节点
    for node in cf.nodes:
        node_type = 'variable' if node in cf.vnames else 'function'
        G.add_node(node, type=node_type)
    
    # 添加边
    for src, dst, label in cf.edges():
        G.add_edge(src, dst, label=label)
    
    return G

# 使用示例
with Storage() as s:
    # 执行一些计算...
    result = complex_computation()
    
    cf = s.cf(result)
    G = mandala_cf_to_networkx(cf)
    
    # 现在可以使用NetworkX的功能
    print("节点数:", G.number_of_nodes())
    print("边数:", G.number_of_edges())
    
    # 拓扑排序
    try:
        topo_sort = list(nx.topological_sort(G))
        print("拓扑排序:", topo_sort)
    except nx.NetworkXUnfeasible:
        print("图包含环，无法进行拓扑排序")
    
    # 寻找最长路径
    if nx.is_directed_acyclic_graph(G):
        longest_path = nx.dag_longest_path(G)
        print("最长路径:", longest_path)
    
    # 使用NetworkX可视化
    plt.figure(figsize=(12, 8))
    pos = nx.spring_layout(G)
    
    # 分别绘制变量和函数节点
    var_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'variable']
    func_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'function']
    
    nx.draw_networkx_nodes(G, pos, nodelist=var_nodes, node_color='lightblue', node_size=500)
    nx.draw_networkx_nodes(G, pos, nodelist=func_nodes, node_color='lightgreen', node_size=500)
    nx.draw_networkx_edges(G, pos, arrows=True)
    nx.draw_networkx_labels(G, pos)
    
    plt.title("Mandala计算图 (NetworkX)")
    plt.axis('off')
    plt.savefig("networkx_visualization.png")
    plt.show()
```

### NetworkX高级分析

一旦转换为NetworkX图，就可以使用其丰富的图分析功能：

```python
def analyze_computation_graph(G):
    """使用NetworkX对计算图进行高级分析"""
    results = {}
    
    # 基本属性
    results["节点数"] = G.number_of_nodes()
    results["边数"] = G.number_of_edges()
    results["是否为DAG"] = nx.is_directed_acyclic_graph(G)
    
    # 连通性分析
    results["是否强连通"] = nx.is_strongly_connected(G)
    results["强连通分量数"] = len(list(nx.strongly_connected_components(G)))
    
    # 中心性度量
    results["度中心性"] = nx.degree_centrality(G)
    results["介数中心性"] = nx.betweenness_centrality(G)
    results["接近中心性"] = nx.closeness_centrality(G)
    
    # 最重要节点
    if results["度中心性"]:
        results["最高度中心性节点"] = max(results["度中心性"].items(), key=lambda x: x[1])
    
    return results

# 使用示例
G = mandala_cf_to_networkx(cf)
analysis_results = analyze_computation_graph(G)

for metric, value in analysis_results.items():
    if isinstance(value, dict):
        print(f"{metric}:")
        for node, score in sorted(value.items(), key=lambda x: x[1], reverse=True)[:5]:
            print(f"  {node}: {score:.4f}")
    else:
        print(f"{metric}: {value}")
```

### 计算路径提取

可以使用NetworkX提取计算过程中的特定路径：

```python
def extract_computation_paths(G, source, target):
    """提取从源节点到目标节点的所有路径"""
    try:
        # 使用NetworkX的simple_paths找出所有简单路径
        paths = list(nx.all_simple_paths(G, source, target))
        return paths
    except nx.NetworkXNoPath:
        return []

# 使用示例
input_nodes = [n for n in G.nodes() if G.in_degree(n) == 0]
output_nodes = [n for n in G.nodes() if G.out_degree(n) == 0]

print("输入节点:", input_nodes)
print("输出节点:", output_nodes)

if input_nodes and output_nodes:
    # 找出从第一个输入到第一个输出的所有路径
    paths = extract_computation_paths(G, input_nodes[0], output_nodes[0])
    print(f"找到 {len(paths)} 条从 {input_nodes[0]} 到 {output_nodes[0]} 的路径")
    
    for i, path in enumerate(paths):
        print(f"路径 {i+1}: {' -> '.join(path)}")
```

## 自定义可视化示例

以下是一个完整的示例，展示如何创建自定义的计算图可视化：

```python
from mandala.imports import *
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np

# 定义一些示例操作
@op
def load_data(source):
    return [1, 2, 3, 4, 5]

@op
def transform(data, factor):
    return [x * factor for x in data]

@op
def aggregate(data1, data2, method="sum"):
    if method == "sum":
        return [a + b for a, b in zip(data1, data2)]
    elif method == "product":
        return [a * b for a, b in zip(data1, data2)]
    else:
        return data1

@op(output_names=["mean", "std"])
def compute_stats(data):
    mean = sum(data) / len(data)
    std = (sum((x - mean) ** 2 for x in data) / len(data)) ** 0.5
    return mean, std

# 执行计算
with Storage() as s:
    raw1 = load_data("source1")
    raw2 = load_data("source2")
    
    processed1 = transform(raw1, 2)
    processed2 = transform(raw2, 0.5)
    
    combined_sum = aggregate(processed1, processed2, "sum")
    combined_prod = aggregate(processed1, processed2, "product")
    
    stats_sum_mean, stats_sum_std = compute_stats(combined_sum)
    stats_prod_mean, stats_prod_std = compute_stats(combined_prod)

    # 创建完整计算图
    cf = s.cf([stats_sum_mean, stats_prod_mean])
    cf.expand_all(inplace=True)
    
    # 转换为NetworkX图
    G = mandala_cf_to_networkx(cf)
    
    # 创建自定义可视化
    plt.figure(figsize=(15, 10))
    
    # 使用分层布局
    pos = nx.nx_agraph.graphviz_layout(G, prog='dot', args='-Grankdir=LR')
    
    # 为不同操作类型定义不同颜色
    color_map = {
        'load_data': '#AED6F1',      # 浅蓝色
        'transform': '#A3E4D7',      # 浅绿色
        'aggregate': '#F9E79F',      # 浅黄色
        'compute_stats': '#F5B7B1'   # 浅红色
    }
    
    # 绘制节点
    for node in G.nodes():
        if node in cf.fnames:
            # 函数节点
            op_name = node.split('.')[0] if '.' in node else node
            color = color_map.get(op_name, '#D2B4DE')  # 默认紫色
            nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color=color, 
                                  node_shape='s', node_size=2000, alpha=0.8)
        else:
            # 变量节点
            nx.draw_networkx_nodes(G, pos, nodelist=[node], node_color='#E5E8E8', 
                                  node_shape='o', node_size=1500, alpha=0.8)
    
    # 绘制边
    nx.draw_networkx_edges(G, pos, width=1.5, alpha=0.7, arrows=True, arrowsize=20)
    
    # 添加标签
    nx.draw_networkx_labels(G, pos, font_size=10, font_family='sans-serif')
    
    # 添加边标签
    edge_labels = {(u, v): d.get('label', '') for u, v, d in G.edges(data=True)}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)
    
    # 添加图例
    legend_elements = [
        plt.Line2D([0], [0], marker='s', color='w', markerfacecolor=color, 
                  markersize=15, label=op_name)
        for op_name, color in color_map.items()
    ]
    legend_elements.append(plt.Line2D([0], [0], marker='o', color='w', 
                                     markerfacecolor='#E5E8E8', markersize=15, 
                                     label='Variable'))
    
    plt.legend(handles=legend_elements, loc='upper right')
    plt.title("数据处理计算图", fontsize=16)
    plt.axis('off')
    plt.tight_layout()
    plt.savefig("custom_computation_graph.png", dpi=300, bbox_inches='tight')
    plt.show()
    
    # 同时保存原始Mandala可视化进行比较
    cf.draw(path="original_computation_graph.png", orientation="LR")
```

这个示例展示了如何将Mandala计算图转换为NetworkX图，并创建自定义可视化，突出显示不同类型的操作。

## 完整的NetworkX集成模块

以下是一个可以添加到项目中的完整NetworkX集成模块示例：

```python
# mandala_networkx.py

import networkx as nx
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

def cf_to_networkx(cf):
    """将Mandala ComputationFrame转换为NetworkX图"""
    G = nx.DiGraph()
    
    # 添加节点
    for node in cf.nodes:
        node_type = 'variable' if node in cf.vnames else 'function'
        if node in cf.vnames:
            # 如果是变量节点，添加其包含的引用数量
            ref_count = len(cf.vs.get(node, set()))
            G.add_node(node, type=node_type, refs=ref_count)
        else:
            # 如果是函数节点，添加其调用数量
            call_count = len(cf.fs.get(node, set()))
            G.add_node(node, type=node_type, calls=call_count)
    
    # 添加边
    for src, dst, label in cf.edges():
        G.add_edge(src, dst, label=label)
    
    return G

def draw_networkx_computation_graph(G, path=None, layout='spring', highlight_nodes=None, title=None):
    """使用NetworkX绘制计算图"""
    plt.figure(figsize=(12, 10))
    
    # 选择布局算法
    if layout == 'spring':
        pos = nx.spring_layout(G, k=0.3, iterations=50, seed=42)
    elif layout == 'dot':
        pos = nx.nx_agraph.graphviz_layout(G, prog='dot', args='-Grankdir=LR')
    elif layout == 'circular':
        pos = nx.circular_layout(G)
    else:
        pos = nx.spring_layout(G)
    
    # 区分变量和函数节点
    var_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'variable']
    func_nodes = [n for n, d in G.nodes(data=True) if d.get('type') == 'function']
    
    # 确定节点大小（基于引用数和调用数）
    var_sizes = [300 + 100 * G.nodes[n].get('refs', 1) for n in var_nodes]
    func_sizes = [400 + 100 * G.nodes[n].get('calls', 1) for n in func_nodes]
    
    # 绘制节点
    nx.draw_networkx_nodes(G, pos, nodelist=var_nodes, node_color='skyblue',
                          node_size=var_sizes, alpha=0.8, node_shape='o')
    nx.draw_networkx_nodes(G, pos, nodelist=func_nodes, node_color='lightgreen',
                          node_size=func_sizes, alpha=0.8, node_shape='s')
    
    # 高亮显示指定节点
    if highlight_nodes:
        highlight_list = [n for n in highlight_nodes if n in G.nodes()]
        if highlight_list:
            nx.draw_networkx_nodes(G, pos, nodelist=highlight_list, 
                                  node_color='red', node_size=700, alpha=0.9)
    
    # 绘制边
    nx.draw_networkx_edges(G, pos, width=1.5, alpha=0.7, arrows=True, 
                          arrowstyle='->', arrowsize=15, edge_color='gray')
    
    # 添加标签
    nx.draw_networkx_labels(G, pos, font_size=9, font_family='sans-serif')
    
    # 添加边标签
    edge_labels = {(u, v): d.get('label', '') for u, v, d in G.edges(data=True)}
    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=7)
    
    # 添加图例
    legend_elements = [
        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='skyblue',
                  markersize=15, label='变量节点'),
        plt.Line2D([0], [0], marker='s', color='w', markerfacecolor='lightgreen', 
                  markersize=15, label='函数节点')
    ]
    if highlight_nodes and any(n in G.nodes() for n in highlight_nodes):
        legend_elements.append(
            plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='red',
                      markersize=15, label='高亮节点')
        )
    
    plt.legend(handles=legend_elements, loc='upper right')
    
    if title:
        plt.title(title, fontsize=16)
    else:
        plt.title("Mandala计算图", fontsize=16)
    
    plt.axis('off')
    plt.tight_layout()
    
    if path:
        plt.savefig(path, dpi=300, bbox_inches='tight')
        print(f"图像已保存至: {path}")
    
    plt.show()
    
def analyze_graph(G):
    """分析计算图的结构和特性"""
    analysis = {
        "基本信息": {
            "节点数": G.number_of_nodes(),
            "边数": G.number_of_edges(),
            "变量节点数": len([n for n, d in G.nodes(data=True) if d.get('type') == 'variable']),
            "函数节点数": len([n for n, d in G.nodes(data=True) if d.get('type') == 'function']),
            "是否有向无环图(DAG)": nx.is_directed_acyclic_graph(G)
        }
    }
    
    # 连通性分析
    analysis["连通性"] = {
        "强连通分量数": nx.number_strongly_connected_components(G),
        "弱连通分量数": nx.number_weakly_connected_components(G)
    }
    
    # 路径分析
    if nx.is_directed_acyclic_graph(G):
        sources = [n for n in G.nodes() if G.in_degree(n) == 0]
        sinks = [n for n in G.nodes() if G.out_degree(n) == 0]
        
        analysis["路径分析"] = {
            "源节点(输入)": sources,
            "汇节点(输出)": sinks
        }
        
        if sources and sinks:
            # 计算关键路径（最长路径）
            longest_path = nx.dag_longest_path(G)
            analysis["路径分析"]["关键路径长度"] = len(longest_path) - 1
            analysis["路径分析"]["关键路径"] = longest_path
    
    # 中心性度量
    analysis["中心性"] = {
        "度中心性最高的节点": max(nx.degree_centrality(G).items(), key=lambda x: x[1]),
        "介数中心性最高的节点": max(nx.betweenness_centrality(G).items(), key=lambda x: x[1]),
        "接近中心性最高的节点": max(nx.closeness_centrality(G).items(), key=lambda x: x[1])
    }
    
    return analysis

def print_analysis(analysis):
    """打印计算图分析结果"""
    for category, metrics in analysis.items():
        print(f"\n== {category} ==")
        for name, value in metrics.items():
            if isinstance(value, (list, tuple)) and len(value) > 6:
                print(f"{name}: {value[:3]} ... {value[-3:]} (共 {len(value)} 项)")
            else:
                print(f"{name}: {value}")

def export_graph_to_file(G, path, format="graphml"):
    """导出计算图到文件"""
    if format == "graphml":
        # 确保所有属性都是兼容的GraphML格式
        for node, data in G.nodes(data=True):
            for key, value in list(data.items()):
                if not isinstance(value, (str, int, float, bool)):
                    data[key] = str(value)
        
        for u, v, data in G.edges(data=True):
            for key, value in list(data.items()):
                if not isinstance(value, (str, int, float, bool)):
                    data[key] = str(value)
        
        nx.write_graphml(G, path)
    elif format == "gexf":
        nx.write_gexf(G, path)
    elif format == "pajek":
        nx.write_pajek(G, path)
    else:
        raise ValueError(f"不支持的导出格式: {format}")
    
    print(f"计算图已导出为{format.upper()}格式: {path}")

def get_execution_order(G):
    """获取计算执行顺序"""
    if not nx.is_directed_acyclic_graph(G):
        raise ValueError("图包含环，无法确定确定性执行顺序")
    
    # 使用拓扑排序获取执行顺序
    topo_order = list(nx.topological_sort(G))
    
    # 过滤出函数节点
    func_nodes = [n for n in topo_order if G.nodes[n].get('type') == 'function']
    
    return func_nodes
```

这个模块提供了将Mandala计算图转换为NetworkX图并进行分析和可视化的完整功能集。可以将其添加到项目中，以便轻松集成NetworkX的强大功能。

## 总结

Mandala框架的计算图可视化和分析功能为理解复杂计算过程提供了强大工具：

1. **内置可视化**：`cf.draw()`方法提供了易于使用的计算图可视化
2. **灵活的参数**：支持多种配置选项来自定义可视化效果
3. **多种分析方法**：提供了丰富的计算图分析工具
4. **与NetworkX集成**：允许利用专业图分析库的强大功能
5. **可导出多种格式**：支持将计算图导出为图像、数据表或图描述格式

通过这些功能，用户可以更深入地理解计算流程、依赖关系和数据流动，从而更有效地开发、调试和优化复杂计算过程。 